#   前端面经

## 1. babel的作用：

```javascript
babel是一个JS编译器，用来转换最新的JS语法，比如把ES6, ES7等语法转化成ES5语法，从而能够在大部分浏览器中运行。像箭头函数，就可以做转换。
```

## 2. webpack的作用：

```javascript
webpack是个打包工具，webpack把所有文件都当成模块(module)
```

## 3.H5新特性有哪些？

## 4.CSS3新特性有哪些？

## 4.如何监控一个对象的变化？列出你所知道的所有方法

## 5.一段字符从后台动态返回，长度不确定，要求显示一行就居中，两行就左对齐，三行就结尾显示'...'

## 6.数据类型？

```javascript
primitive(原始类型)
1.string 字符类型
2.number 数字类型
3.boolen 布尔类型
4.undefined 未定义
5.null 空
-----------------
6.object 对象类型
```

## 7.undefined和null的区别？

```javascript
首先这两个类型==是相等的，但是===是不同的。所以这两个类型不是一回事。
undefined是声明了一个变量但是未赋值
而null代表空值，它种类属于object，是一个空指针
```

## 8.undefined的几种情况？

```javascript
（1）变量被声明了，但没有赋值时，就等于undefined。

（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

（3）对象没有赋值的属性，该属性的值为undefined。

（4）函数没有返回值时，默认返回undefined。
```

## 9.[],{},null,undefined,NaN分别是TRUE还是FALSE？

```javascript
[],{}是true
null,undefined,NaN是false
```

## 10.==，===运算符注意的问题？

```javascript
1.==的问题
如果两边类型相等，==直接变为===
undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。
String == Boolean，需要两个操作数同时转为Number。
String/Boolean == Number，需要String/Boolean转为Number。
Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)

[] == [] 为false，因为两边类型相等，直接变为===
[] == ![] 为true，因为!优先级高，所以![]是布尔型，从true变为false
[] == 0 为true
[] == true 为false
NaN == NaN 为false，两个都不是数所以无非判定是否相等
{}和谁也不等，因为{}指向了内存中的一个地址，只有有一个和它指向一个地址的对象才对
-----------------------
2.===的问题
===为完全相等才为true
[] === [] 为false，因为它两不在一个地址
```

## 11.prototype和\__proto__的关系:

![关系图](C:\Users\51146\Desktop\图片1.png)

## 12. 防抖和节流？

```javascript
防抖:在一定时间内，一个事件会连续触发多次，不仅没用还会占用浏览器性能。防抖就是让多次执行变为最后一次执行，而且不影响结果。
    	// 防抖
        function debounce(fn, delay) {
            let timer;
            return function (e) {
                clearTimeout(timer);
                timer = setTimeout(() => {
                    fn.call(this, e);
                }, delay);
            }
        }
		window.addEventListener('scroll', debounce(haha, 500));
节流：节流是将多次执行变成每隔一段时间执行
  		// 节流
        function throttle(fn, delay) {
            let lastTime = 0;
            return function (e) {
                let nowTime = new Date();
                if (nowTime - lastTime > delay) {
                    fn.call(this, e);
                    lastTime = nowTime;
                }
            }
        }
		window.addEventListener('scroll', throttle(haha, 3000))
```

## 13. display:none和visibility:hidden的区别有哪些？ 

```java
1.同样是隐藏元素，display:none不占位置，visibility:hidden占位置
2.父元素设置display:none，子元素改成display：block也不会显示。父元素设置visibility：hidden，子元素设置visibility：visible可以显示
3.display：none位置会发生变化，发生回流。visibility：hidden位置不变化，发生重绘
```

## 14. 定位的属性

```java
1.相对定位relative：相对于之前自身的位置，没有脱离文档流
2.绝对定位absolute：相对于包含块的位置，脱离了文档流（包含块：离它最近开启定位的祖先元素）
3.固定定位fixed：相对于页面视口（你看到的页面范围，就算页面利用滚动条拖动，它还是在你看到的位置）的位置，脱离了文档流
4.粘滞定位sticky：到了一定位置，不产生移动，脱离了文档流
```

## 15. CSS权重值

```java
1.!important
2.内联样式
3.id选择器
4.class选择器
5.元素选择器
6.通配选择器
7.继承样式
```

## 16. box-sizing的属性值

```html
content-box和border-box。区别为content-box的width对应的是内容区，border-box的width的范围为边框
```

## 17. 有一个标签设置float浮动，标签下的文字会以什么样的形式呈现

```html
文字围绕标签包裹住，浮动标签属于半脱离文本流
```

## 18. em rem的区别

```html
1em是对应元素的字体大小
1rem（rootem）是html元素的字体大小
```

## 19. 原型链？var person = new Person(); 这个new做了几件事情？

```JavaScript
原型链：在JavaScript中是通过prototype对象指向父类对象，比如Person.prototype就是它的父类对象Object，直到指向Object.prototype.__proto__ = null为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。
new:创建一个新对象 -> 让对象.__proto__ === 构造函数.prototype -> 将this指向新对象 -> 返回结果
复现new
function Person(name, age){
    this.name = name;
    this.age = age;
}
function myNew(className, ...args){
    //Object.create()方法创建一个新的对象，让现有的对象给新的对象提供__proto__。
    let obj = Object.create(className.prototype);
    className.apply(obj, args);
    return obj;
}

let newPerson = myNew(Person, 'zs', 12);
```

## 20. 深浅拷贝（RegExp在深拷贝里是干啥）

```JavaScript
值引用：把值传给新的变量
地址引用：把地址传给新的变量
值引用为深拷贝，地址引用为浅拷贝
------------
深拷贝：
	数组的方法：
    	1.arr1 = arr2.slice();
		2.arr1 = arr2.concat();
		3.arr1 = [...arr2]
		缺点：数组中的引用类型还是没有被深拷贝
	对象的方法：
		1.objString = JSON.stringify(obj);obj1 = JSON.parse(objString)
			缺点：不可以拷贝undefined，function，RegExp等
		2.obj1 = Object.assign({}, obj);
			缺点：对象中的引用类型还是没有被深拷贝
        3.obj1 = {...obj2}
	数组和对象递归深拷贝：
 		function deepClone(source) {
            let target;
            // 首先判断是不是对象类型
            if (typeof source === 'object') {
                // 判断是不是数组
                if (Array.isArray(source)) {
                    target = [];
                    for (let i = 0; i < source.length; i++) {
                        target[i] = deepClone(source[i]);
                    }
                }
                // 判断是不是空指针
                else if (source === null) {
                    target = null
                }
                // 判断是不是正则
                else if (source.constructor === RegExp) {
                    target = source
                }
                // 只剩下普通对象类型
                else {
                    target = {};
                    for (let v in source) {
                        target[v] = deepClone(source[v]);
                    }
                }
            }
            else {
                // 普通类型直接引用
                target = source;
            }
            return target;
        }
```

## 21. 标准盒模型和IE盒模型的区别？

```html
标准盒模型：content范围只有content。相当于box-sizing:content-box
IE盒模型：content范围到border。相当于box-sizing:border-box
```

## 22. 闭包？会造成什么问题？如何避免？

```html
闭包：
	函数里嵌套函数，内部函数调用外部函数的变量，构成闭包。
闭包的作用：
	1.延长局部变量的生命周期
	2.访问函数内部参数
闭包的缺点：
	会造成内存泄漏。
如何避免：
	最后释放闭包
	f = null;
```



## 23. HTTP状态码（查一下看看）

```html
301（资源被永久转移到其他url）
302（临时重定向）
304（协商缓存）
305（所请求的资源必须通过代理访问）
------
客户端的问题
400（客户端请求的语法有误，服务器无法识别）
401（要求用户身份认证）
403（拒绝请求）
404（找不到页面）
405（客户端请求的方法被禁止）
408（服务器等待客户端超时）
------
服务器端问题
500（服务器报错）
501（服务器不支持请求功能，无法完成请求）
502（网关或代理服务器发起请求时，从远程服务器接收到了无效的响应）
503（服务禁止访问）
504（网关或代理服务器，未及时请求远程服务器）
505（服务器不支持该http版本）
```

## 24. 页面布局有哪几种

```html
固定布局：设置固定宽高，用px
流式布局：宽度用百分比来设定，高度用px来固定
栅格化布局：将宽度人为划分成均等长度
自适应布局：根据不同的分辨率构造不同的静态页面
响应式布局：流式布局和自适应布局的结合
弹性布局：弹性布局跟流式布局很像，网页宽度不固定，使用 em 或 rem 单位进行相对布局
伸缩布局：使用flex属性来进行布局
-------------
自适应布局和响应式布局对比：
	不同点：
　　　　1.自适应需要开发多套界面；响应式只需开发一套界面。
　　　　2.自适应对页面的屏幕适配实在一定的范围，比如：pc 端大于1024px; 平板 768 ~ 1024px; 手机端小于 768px;响应式是一套页面同时兼容在pc端、平板和手机端的各个不同视口，而不是为每个终端做一个特定的版本，所以需要考虑的状态非常多
	相同点：　
　　　　都是通过检测视口分辨率，使页面适应不同分辨率的视口。
```

## 25. DOM的事件类型

```html
事件传播流程：先捕获到事件点再冒泡。捕获是从外向内，冒泡是从内向外
事件捕获
事件冒泡
```

## 26. target和currentTarget的区别

```html
都是点击以后返回相应的元素。但是点击以后，因为有冒泡的存在，可能有多个事件发生。
1.target:
	发生在事件流的目标阶段
	返回真实点击的那个元素
2.currentTarget：
	发生在事件流的捕获、目标及冒泡阶段
	返回事件发生的那个元素
```

## 27. React生命周期

![生命周期](C:\Users\51146\Desktop\图片2.png)

```js
挂载路线：
constructor-->componentWillMount-->render-->componentDidMount-->componentWillUnmount
更新路线分为三类：
	 (1)父节点使用setState函数，触发render,componentWillReceiveProps可以接收props参数
    	componentWillReceiveProps-->shouldComponentUpdate-->componentWillUpdate-->render-->componentDidUpdate-->componentWillUnmount
     (2)使用setState函数时，触发render
        shouldComponentUpdate-->componentWillUpdate-->render-->componentDidUpdate-->componentwillUnmount
     (3)this.forceUpdate强制刷新，所以不需要shouldComponentUpdate进行判断
		componentWillUpdate-->render-->componentDidUpdate-->componentWillUnmount
```

![新生命周期](C:\Users\51146\Desktop\图片3.png)

```js
新生命周期：
	废除了三个旧的钩子，新添加了两个。getDerivedStateFromProps、getSnapshotBeforeUpdate。
    getDerivedStateFromProps:首先需要定义为静态方法，它可以接收到的参数为props，接着它的返回值可以是null，或者是state属性值。如果为state属性值，就决定了该state属性值之后不会改变。所以一般用在props决定的state值上。
    getSnapshotBeforeUpdatge:可以获取更新前的props、state，返回更新前的参数，传给componentDidUpdate。
    componentDidUpdate:可以接收三个参数，更新前的props、更新前的state、getSnapshotBeforeUpdate的返回值，所以会在这一步根据前一个生命周期函数返回来的值，做一些事情。
    挂载时期路线：
    	constructor-->getDerivedStateFromProps-->render-->componentDidMount
    更新路线：
    	new props和setState路线：
			getDerivedStateFromProps-->shouldComponentUpdate-->render-->getSnapshotBeforeUpdate-->componentDidUpdate
        forceUdpate路线：
        	getDerivedStateFromProps-->render-->getSnapshotBeforeUpdate-->componentDidUpdate
    挂载路线：
    	componentWillUnmount
```



## 28. bind, apply, call区别

```html
三个都可以改变this的指向
apply:第一个参数为this的新指向，第二个参数是数组，数组里是传入的实参。f.apply(obj,[args])
call:第一个参数为this的新指向，后面的参数是传入的实参。f.call(obj, arg1, arg2, arg3)
bind:用法和前两个不一样,第一个是this的新指向返回一个新函数，然后再调用。f.bind(obj)(arg1,arg2)
```

## 29. 前端缓存

```html
前端缓存可分为两大类：
	http缓存：是在http请求传输时用到的缓存，主要在服务器代码上设置
		1.强缓存：
			-Expires：值为服务器返回该请求结果的缓存到期时间。（http/1.0控制网页缓存的字段）
				规则：客户端请求资源的时间和到期时间作比较，如果超了，强制缓存失效
				缺点：如果时区不同，时间出了问题等，强缓存就会失效
			-Cache-control：（http/1.1控制网页缓存的字段优先级大于Expires）
				参数：
                    public：所有内容都将被缓存（客户端和代理服务器都可缓存）

                    private：所有内容只有客户端可以缓存，Cache-Control的默认取值

                    no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定

                    no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存

                    max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效
				规则：不会出现Expires那样的问题，因为通过相对时间来决定强缓存是否失效。客户端请求时间没有超过max-age，就可以使用浏览器缓存

		2.协商缓存：当强缓存失效以后，浏览器携带缓存标识向服务器发起请求，决定是否可以使用浏览器缓存。
			-Last-Modified / If-Modified-Since：Last-Modified为服务器端响应请求时，该资源文件最后被修改的时间。If-Modified-Since：客户端发起请求时携带Last-Modified的值，与服务器端该资源最后一次做修改的时间进行比对，来决定是否允许客户端请求浏览器缓存。
			-Etag / If-None-Match：（优先级大于Last-Modified / If-Modified-Since）Etag为服务器端响应请求时，返回该资源文件的唯一标识。If-None-Match是客户端再次发起请求时，携带Etag的值。服务器端识别到If-None-Match时，将它的值和当前服务器端该资源文件的Etag值做比较。相同的话返回304可以使用强缓存，不可以的话使用新资源返回200，并将新资源存入浏览器缓存中。
-------------------------------------------------
	本地缓存：
		1.本地存储
			小容量：
				cookie：存储用户信息，
				LocalStorage:一直存储在浏览器内，直到用户清除浏览器缓存数据
				SessionStorage:一直存在，直到关闭标签页
			大容量：
				WebSql:关系型数据库
				IndexDB:非关系型数据库
		2.默认存储
			BFCache:是浏览器在前进后退按钮上为了提升历史页面的渲染速度的一种策略。当到下一个页面时，将该页面的状态存入BFCache中。返回时，直接从BFCache中加载。
--------------------------------------
缓存小结
当浏览器要请求资源时

调用 Service Worker 的 fetch 事件响应
查看 memory cache
查看 disk cache。这里又细分：
如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200
如果有强制缓存但已失效，使用对比缓存，比较后确定 304 还是 200


发送网络请求，等待网络响应
把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)
把响应内容 的引用 存入 memory cache (无视 HTTP 头信息的配置)
把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())
```

## 30. 设计模式

```JavaScript
1.单例模式：
	定义：保证一个类只有一个实例对象，并且提供一个访问点
    实现：用一个变量来标识实例是否已经存在，如果存在，则直接返回已经创建好的实例，反之就创建一个对象
    优点：不用重复开启多个实例，节省内存开销
class SingletonApple {
  	constructor(name, creator, products) {
    this.name = name;
    this.creator = creator;
    this.products = products;
  	}
  	//静态方法
  	static getInstance(name, creator, products) {
    	if(!this.instance) {
      		this.instance = new SingletonApple(name, creator, products);
    	}
   		return this.instance;
  	}
}

let appleCompany = SingletonApple.getInstance('苹果公司', '乔布斯', ['iPhone', 'iMac', 'iPad', 'iPod']);
let copyApple = SingletonApple.getInstance('苹果公司', '阿辉', ['iPhone', 'iMac', 'iPad', 'iPod'])

console.log(appleCompany === copyApple); //true
2.观察者模式：
 // 观察者模式
        class Publisher{
            constructor(){
                this.list = []
            }
            listen(fn){
                fn && this.list.push(fn)
            }
            publish(){
                for(let i in this.list){
                    let fn = this.list[i];
                    fn.apply(this, arguments);
                }
            }
        }
        let newPublisher = new Publisher();
        newPublisher.listen((price)=>{
            console.log('我是小红' + price);
        })
        newPublisher.listen((price)=>{
            console.log('我是小黄' + price);
        })
        newPublisher.publish('价格5元');

3.消息订阅模式：
定义：有一个中间件。发布者发信息在中间件中，订阅者从中间件中获取自己
		class Publisher{
            constructor(){
                this.list = {}
            }
            listen(name, fn){
                if(!this.list[name]){
                    fn && (this.list[name] = [fn]);
                }
                else{
                    fn && this.list[name].push(fn);
                }
            }
            publish(){
                let key = arguments[0];
                let arr = Array.from(arguments);
                arr.shift()
                this.list[key].map((item)=>{
                    item.apply(this, arr)
                })
            }
        }

        let newPublisher = new Publisher();
        newPublisher.listen('小红', (price)=>{
            console.log('heiheihei' + price);
        })
        newPublisher.listen('小红', (price)=>{
            console.log('hahaha' + price);
        })
        newPublisher.listen('小黑', (price)=>{
            console.log('小老弟', price);
        })

        newPublisher.publish('小黑','五折起');
```

## 31. 继承

```js
1.Es5继承：
	function Person(name, age){
        this.name = name;
        this.age = age;
    }
	Person.prototype.fun = function(){
        console.log(1);
    }
子类：
	function SmartPerson(name, age, gender){
        Person.call(this, name, age);
        this.gender = gender;
    }
	SmartPerson.prototype = new Person();

2.Es6继承：
	class Person{
        constructor(name, age){
            this.name = name;
            this.age = age;
        }
        fun(){
            console.log(1);
        }
    }
子类：
	class SmartPerson extends Person{
        constructor(name, age, gender){
            super(name, age);
            this.gender = gender;
        }
    }
```



## 32. BFC

```html
BFC（块级格式化上下文）:是一个独立的布局环境，其中的元素布局不受外界的影响。解决了内部塌陷问题、父子外边距问题等
开启BFC:
	1.设置float:left(不推荐)
	2.display:inline-box、table-cell、flex、table-caption或者inline-flex(不推荐)
	3.overflow:hidden(除了visible都可以)
	4.position的值不是static或者relative
```

## 33. 为什么const定义的变量不能修改，定义的对象里的内容能修改

```html
因为const指向的地址不可以改变，但是地址里的内容改变，不会改变指针的指向。
为什么必须初始化？（个人理解）
因为基本类型和指针都放在栈内存，而对象类型都放在堆内存。又因为const的指针不可以改变，所以必须开始就申明指针。如果之后再赋值相当于修改指针位置了，不符合const的逻辑
```

## 34. **sessionStorage、localStorage和cookie的区别**

```html
共同点：都是保存在浏览器端、且同源的 
区别： 
1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递,因为cookie的本质是进行身份验证，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 
2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 
3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 
4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 
```

## 35. css模块化的优点

```html
css模块化定义：
	原始的思维：在设计页面时，从页面整体开始到每一个部分，是一个自上而下的过程，所以很容易css结构只能用在这一个页面上，不能进行css代码复用
	css模块化：是自下而上的，设计每一个模块，这些模块可能用在多个页面只有一些细微的差别，任何一个页面也只不过是这些模块的拼凑。
OOCSS规则：
	上下文无关：这个模块该怎么样就怎么样，不会因为其他元素影响到它。
	不用id，用class：如果要用的代码复用，要用class，因为id只能使用单个元素
BEM规则：
	B 是block，简单理解就是BFC
	E 是element，某一个块独用的子元素。比如菜单里的菜单项
	M 是Modifier，只做修饰的作用
	命名规则：
		B--M,B用M来修饰
		B__E,E是B的子元素
SMACSS规则：
	在OOCSS和BEM的基础上添加了新的概念，在BEM的命名前缀上添加类别，不同类别的处理方式也有不同。
	比如：	
		l- 用作布局规则的前缀：l-inline
		m- 用作模块规则的前缀：m-callout
		is- 用作状态规则的前缀：is-collapsed
		不加前缀就是HTML元素的默认样式
css模块化优点：
	是可预测的，可维护的并且是高性能的
```

## 36. 轮播图组件的实现

## 37. 数组去重几种方法

## 38. http1.0与1.1以及2.0的特点，http首部字段报上来，与https的区别

```js
1.http1.0:
	使用的是短连接，每有一次HTTP请求，就会进行一次TCP的连接。如果上一个请求没有响应，之后的请求无法进行，造成阻塞

2.http1.1:
	使用的是长连接，长连接要求客户端和服务器端的头部connection字段设置为keep-alive。当进行HTTP请求后，TCP的连接就不会断开，直到一定时间没有进行HTTP请求才会断开。服务器根据客户端请求的顺序，来进行响应（比如客户端先请求html再请求css。服务器端就算css资源准备好，也得等html资源响应之后再进行响应），所以也会产生阻塞问题。
	http1.1所谓的并行，只不过是可以同时多开几个TCP连接，但是各个浏览器有TCP连接个数的限制，而且每个TCP连接依旧是单线程的。
	在http1.1加入了缓存处理（强缓存和协商缓存），新增了字段如cache-control。（但是expires是在1.0就有。所以强缓存是啥时候出来的？）

3.http2.0：
	不再采用文本形式，而是采用二进制分层帧，解决了很多解析等问题。每个数据流用信息的方式来发送，信息里由一个或多个帧组成不需要按顺序，每个帧的头部都会有流id（stream_id），最后根据流id来进行封装。实现了真正的并行传输，只在一个TCP上进行。
    还进行了头部压缩。在HTTP2.0之前，每次发送http请求都会将头部信息也发送过去，在同一资源数量非常大的情况下很浪费资源。HTTP2.0使用encoder减少了头部的大小，而且在客户端和服务器端各自cache了一份header_file表，避免重复头部信息的发送，只有有头部信息发生改变才会更新发送。
    新增了服务器推送功能，就是响应除了客户端要求的内容，服务器端可以额外发送资源。（比如客户端请求了html，服务器端不光响应了html内容，还响应了css和js内容）
```

## 39. 短轮询和长轮询

```js
以电商库存为例
1.短轮询：客户端进行库存数量的请求，服务器不管库存有没有更新立即响应库存数量。
2.长轮询：客户端进行库存数量的请求，服务器先将该请求挂起，当有库存数量有变化立即响应，如果一定时间库存数量没有变化，再返回结果。

因为客户端请求是根据有没有响应来判断需不需要继续请求。很明显长轮询的请求次数要比短轮询要少的多，但是长轮询的缺点是会导致资源的浪费
```

## 39. 前端模块化

## 40. 跨域 同源策略 cors jsonp原理 缺点 手写jsonp

```js
同源策略：两个页面具有相同的协议、域名、端口号。
跨域：只要违反同源原则就产生了跨域
cors: 
	整个cors通信过程，是浏览器自动完成的，不需要用户参与。当发现跨域请求时，在请求头部自动添加字段。整个cors通信的关键是服务器，只要在服务器端添加cors接口，就可以实现跨域通信。
    cors分类：
    	cors分为简单请求和非简单请求。这样分类的原因只要是和form表单有关。
        简单请求：
        	满足两大条件的请求就是简单请求
            	(1)请求方法：
                	GET,POST,HEAD
				(2)头部字段:
					Accept、Accept-Language、Content-Language、Last-Event-ID、Content-type:只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
		非简单请求：
        	只要不满足上边任意一条就属于非简单请求。
            每次发送前都得发送预检请求，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些http动词和头信息字段，只有得到肯定答复才会正式发出请求，否则就报错。
jsonp原理：利用script可以跨域的原理，进行跨域请求。
缺点：
	1.因为script发起的是get请求，所以jsonp只能进行get请求
    2.只能发起http请求，所以不能进行页面之间的信息传递
    3.jsonp请求失败不会返回各种http状态码
    4.不安全。例如XSS攻击
手写：
	前端：
    	function fun(data){
            console.log(data);
        }
    	let script = document.createElement('script');
		script.src = 'http://127.0.0.1?callback=fun'
		document.body.appendChild(script);
	后端：
    	import express from 'express'
		const app = express();
		app.get("/", (req, res) => {
            let fun = req.query.callback;
            let data = {
                message:'棒',
                age:12
            }
            res.send(`${fun}(${JSON.stringify(data)})`);
        });
			
		app.listen(80, () => {
            console.log('server is running');
        });
```



## 41. post get区别

## 42. 计网传输层看一下

## 43. 回流 重绘

```js
回流（重排）：
	当页面布局发生变化时，会发生回流
重绘：
	当页面颜色等样式发生变化时，会发生重绘
重绘发生在回流之后。所以只要发生回流必然会发生重绘。
浏览器会做优化，当页面变化到一定程度时
当时使用获取元素尺寸的api时，会引起回流，并且会刷新刷新队列。
```

## 44. http输入url后的详细步骤

```
1.输入url
url：url由协议、域名、端口号、文件路径组成。
	协议一般有：http://(超文本传输协议)、https://(进行加密的网络传输协议)、file://(本地文件传输协议)、ftp://(文件传输协议)
	域名：域名是唯一的，但是一个域名可能对应多个ip地址，多个ip地址也可能对应多个域名
	端口号：http-80、https-443、ftp-21、smtp-25
	文件路径：一般是该文件在服务器中存放的路径
2.域名解析，将域名转换为ip地址
域名解析过程：
	1.浏览器缓存
	2.系统缓存，从hosts文件中寻找
	3.路由器缓存
	4.ISP DNS缓存，从网络服务商中寻找DNS缓存信息
	5.根域名服务器
	6.逐级上升直到顶级
期间可能会发生DNS劫持问题：
	将域名解析过程拦截，更改解析ip地址或者不解析
当dns配置出错导致无法上网，可以把dns配置的dns服务器地址改为8.8.8.8或114.114.114.114
3.请求服务器：
如果是http请求，进行TCP三次握手，就可以进行信息传递了。
如果是https请求，先进行TCP三次握手，再进行TLS/SSL层连接，就可以进行信息传递了。
到达服务器，通过统一资源标识符(URI)，找到对应路径，然后进行相应的操作。
4.页面渲染：
浏览器会将服务器端传来的html文件，进行解析渲染。
渲染过程：
	浏览器通过网络进程接收到html文件，然后将其通过进程间通道IPC，传到渲染进程。渲染进程又分为多个线程，分别有主线程、合成器线程、栅格线程。
	主线程先对html进行解析，html中会引入css、图片、js文件等。css、图片等不会影响html的解析，可以从缓存中或从服务器请求。但是js会影响html的解析，因为js可能会导致DOM树的变化，所以先要等js执行结束，继续向下解析html，等解析结束生成DOM树。生成完DOM树之后需要解析css文件生成CSSOM，将DOM树和CSSOM结合生成layout树，layout树和DOM树是有区别的，因为可能有display：none等属性，在这个阶段进行布局。当生成完layout树之后，需要遍历一遍layout树，因为需要判断绘制顺序（比如：z-index会影响到位置），生成了绘制顺序表。知道绘制顺序，将这些内容交给合成器线程，进行分块。再交给栅格线程进行栅格化。当需要展示什么内容时，将栅格线程中的需要展示的内容交给合成器线程。再转交给GPU进程，GPU进程处理完后交给用户进程进行展示。
	优化：当一个不断发生回流重绘过程的组件，和js共用一个主线程。当一个js执行时间很久就会产生掉帧的情况，所以可以使用requestAnimationFrame()这个api，因为它会将一个js执行过程均匀分配在每一帧，这样就不会影响到渲染；或者在使用动画时，采用transform的属性，因为该属性不会导致布局和绘制，所以不在主线程上进行，不会影响渲染。opacity也不会发生回流重绘
	
js的defer、async属性：
	defer：脚本将在页面完成解析时执行，不影响解析，可以先下载。有序
	async：不影响html解析，可以下载完执行，无序，谁先下载完谁先执行
	它们两不可作用于内联script
```



## 45. 平时怎么清除本地的缓存

## 46. CSS的水平垂直居中？已知宽高和未知宽高的都说一下？

## 47. flex:auto和flex:1有什么区别

## 48. link引入和@import引入的区别？

```html
@import用法:
	1.@import url(style.css)
	2.@import url("style.css")
	3.@import "style.css"
1.link是html标签，不止限于引入css样式。而@import属于css范畴，只能加载css
2.link是在页面加载时同时加载。而@import是页面加载完才加载
3.link是html标签所以没有兼容性问题，@import是css2.1之后提出的，所以会有兼容性问题
```

## 49. 宏任务和微任务

```js
优先级：主线程上任务 > 微任务队列里的任务 > 宏任务队列里的任务
宏任务：
	分类：setTimeout,setInterval,requestAnimationFrame，DOM事件，AJAX请求
	当主线程上没有任务，且微任务队列中没有任务，将宏任务队列里的第一个任务放入主线程上
微任务：
	分类：Promise().then(回调)，process.nextTick
	当主线程上没有任务，将微任务队列里的任务放入主线程上。
```

## 50. 网页图片的懒加载，并手写

```js
	对页面进行的一种优化。在加载页面时先不加载图片，直到需要显示的时候，再进行加载。
    将img放入div中，img的src设置为空，可以使用div的默认样式等。然后用到getBoundingClientRect()这个api。getBoundingClientRect().top是元素到视口的距离。document.documentElement.clientHeight是视口的高度。当元素距离视口的距离和视口大小一样或者小于时，就要显示图片了。这时把img的src改成图片路径，图片就加载出来了。
	整个过程要用到防抖或节流，因为滚动事件会连续触发事件，影响性能。
    	let dataSrc = './img/u=1580462615,710030920&fm=253&fmt=auto&app=138&f=JPEG.webp';
        let box = document.getElementById('box');
        let img = document.getElementsByTagName('img')[0];
        let lazyLoad = function (e) {
            if(box.getBoundingClientRect().top <= document.documentElement.clientHeight){
                console.log('成了');
                img.src = dataSrc;
            }
        }
         // 防抖
        function debounce(fn, delay) {
            let timer;
            return function (e) {
                clearTimeout(timer);
                timer = setTimeout(() => {
                    fn.call(this, e);
                }, delay);
            }
        }
  		window.addEventListener('scroll', debounce(lazyLoad, 500));
```

## 51. http和https的区别（补充）

```js
http是明文传输协议，所以信息被截取以后，安全隐患很大。https要比http安全，因为在https下多加了一SSL/TSL层。
```

## 52. 对称加密和非对称加密

```js
对称加密：
	对话双方用的同一个密钥。A方用密钥将明文加密以后，传给B方，B方通过这个密钥将密文解成明文。
非对称加密：
	对话双方各自用自己的一对密钥。当A方想给B方发文件，这时就让B方把他的公钥发给A，A将自己的明文通过B给的公钥加密，发给B，B用自己的密钥对该密文进行解密。
对称加密优缺点：
	优点：加密解密速度快。
    缺点：密钥的传递会有安全问题。
非对称加密优缺点：
	优点：公钥传递不用考虑安全性。
    缺点：加密解密速度慢
```

## 53. https的加密原理

```js
	https用到了对称加密和非对称加密。
	考虑到加密解密的效率所以要用对称加密，但是对称加密的传输有了安全问题。利用非对称加密的安全传输性，通过非对称加密将对称加密的密钥传输给浏览器和服务器双方。
	但是使用非对称加密也会有隐患。服务器端将公钥A传给浏览器，中间人进行劫持，留下公钥A，将自己的公钥B传给浏览器，浏览器将自己的对称密钥x通过公钥B传给中间人，中间人利用自己的密钥B解密，得到密钥x，然后将密钥x通过公钥A传给服务器。整个过程服务器和浏览器不知道，但是中间人已经拿到了密钥x。
	所以为了解决这个问题，引入了权威机构CA发布的数字证书，浏览器就知道自己接收到的公钥是不是来自服务器。首先每个电脑都有CA机构的公钥。CA发送证书时，会将一串明文进行hash，然后CA利用私钥将该数据加密生成数字签名，将明文和数字签名发给浏览器。浏览器将数字签名用CA的公钥解开为S’，然后将明文进行hash形成T’。将S’和T’进行比较，如果相同说明没有问题。
	进行一次hash的原因是非对称加密，有长度的限制，而且长度固定以后，会加快非对称加密和解密的速度。
    每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？显然不会，太耗时。服务器端会根据sessionID存储密钥，浏览器端会每次传送时将sessionID也一并传送过去。服务器端根据sessionID来寻找密钥。
```

## 54. https通信流程

```js
1.客户端向服务器端请求CA证书
2.客户端验证证书
3.验证通过
4.通过服务器公钥加密随机生成的对称密钥x
5.服务器通过密钥解密获得对称密钥x
6.双方进行通信
```

## 55. element.style和getComputedStyle()的区别

```html
element.style可以修改element样式是可读写，但是只能涉及到元素的内联样式
getComputedStyle()是只读属性，可以读到元素的最终属性（包括内敛、外部样式等）。
getComputedStyle(元素，伪元素字符串)
<style>
    h3::after {
        content: "rocks!";
    }
</style>

<h3>generated content</h3>

<script>
    let h3 = document.querySelector('h3'),
    result = getComputedStyle(h3, '::after').content;
    alert(`the generated content is: ${result}`);
    console.log(`the generated content is: ${result}`);
    // the generated content is: "rocks!"
</script>
```

## 56. offsetHeight、clientHeight、scrollHeight的区别

```js
offsetHeight是加边框的大小
clientHeight是加padding的大小
scrollHeight是整个内容区的文本大小
```

## 57. offsetTop、clientTop、scrollTop的区别

```js
offsetTop是顶部距离包含块的距离
clientTop是上边框的宽度
scrollTop是滚动的距离
```

## 58. 手撕Promise

```js
function Promise(executor) {
    // 设定初始状态
    this.PromiseState = 'pending';
    // 设定promise的值
    this.PromiseResult = null;
    // 设定发生异步时，存入的then里的函数
    this.callback = [];
    // 调用resolve，改变Promise状态为fulfilled
    let resolve = (data) => {
        this.PromiseState = 'fulfilled';
        this.PromiseResult = data;
        // 等异步结束，响应对应的多个then函数
        for (let i in this.callback) {
            this.callback[i].onResolve(data)
        }
    }
    // 调用reject，改变Promise状态为reject
    let reject = (data) => {
        this.PromiseState = 'reject';
        this.PromiseResult = data;
        // 等异步结束，响应对应的多个then函数
        for (let i in this.callback) {
            this.callback[i].onReject(data);
        }
    }
    // 捕获报错，报错Promise从pending状态变为reject状态
    try {
        // 同步执行promise执行器里的函数  
        executor(resolve, reject);
    } catch (error) {
        reject(error)
    }

};
Promise.prototype.then = function (onResolve, onReject) {
    return new Promise((resolve, reject) => {
        // 当状态为fulfilled时，执行第一个形参里的函数
        if (this.PromiseState === 'fulfilled') {
            let result = onResolve(this.PromiseResult)
            // 判断返回是不是Promise对象
            if (result instanceof Promise) {
                // 当第一个函数返回结果为Promise的fulfilled时，then返回promise的fulfilled状态
                if (result.PromiseState === 'fulfilled') {
                    resolve(result);
                }
                // 否则，返回Promise的reject
                if (result.PromiseState === 'reject') {
                    reject(result);
                }
            }
            else {
                resolve(result);
            }
        }
        // 当状态为reject时，执行第二个形参里的函数
        if (this.PromiseState === 'reject') {
            let result = onReject(this.PromiseResult)
            if (result instanceof Promise) {
                // 当第一个函数返回结果为Promise的fulfilled时，then返回promise的fulfilled状态
                if (result.PromiseState === 'fulfilled') {
                    resolve(result);
                }
                // 否则，返回Promise的reject
                if (result.PromiseState === 'reject') {
                    reject(result);
                }
            }
            else {
                resolve(result);
            }
        }
        // 当状态为pending时，将函数存入callback数组中，等状态变化后执行
        if (this.PromiseState === 'pending') {
            this.callback.push({
                onResolve: () => {
                    try {
                        let result = onResolve(this.PromiseResult)
                        // 判断返回是不是Promise对象
                        if (result instanceof Promise) {
                            result.then(v => {
                                resolve(v)
                            }, r => {
                                reject(r)
                            })
                        }
                        else {
                            resolve(result);
                        }
                    } catch (error) {
                        reject(error)
                    }

                },
                onReject: () => {
                    try {
                        let result = onReject(this.PromiseResult)

                        if (result instanceof Promise) {
                            // 当第一个函数返回结果为Promise的fulfilled时，then返回promise的fulfilled状态
                            if (result.PromiseState === 'fulfilled') {
                                resolve(result);
                            }
                            // 否则，返回Promise的reject
                            if (result.PromiseState === 'reject') {
                                reject(result);
                            }
                        }
                        else {
                            resolve(result);
                        }
                    } catch (error) {
                        reject(error)
                    }

                }
            })
        }
    })

}
```

## 59. 受控组件和非受控组件

```js
受控组件：
	有多个输入框时，把输入的内容存在state里，保存下来的组件叫受控组件
非受控组件：
	即存即用的组件，一般存在ref中
一般最好使用受控组件，因为react官方建议少用ref
```

## 60.函数柯里化和闭包

```js
函数柯里化：是特殊的闭包，将多层函数里的参数，一起使用最后返回。
闭包：使用函数内部参数
```

## 61. reduce

```js
reduce是数组的一个方法，有两个参数，第一个参数为回调函数，第二个可选参数为初始值。
回调函数的参数又有四个，第一个参数为上一状态返回值，第二个为当前值，第三个为当前索引，第四个为reduce的数组。
如果没有设置初始值，数组索引将从第二个开始，因为没有返回的前一个状态。而设置了初始值的话，索引从第一个开始，因为前一状态为初始值。

//求和
let arr = [1, 2, 3, 4]
arr.reduce((pre, cur, index)=>{
    return pre + cur;
},0)

//拍平数组
function flat(arr){
    return arr.reduce((pre, cur, index)=>{
        // 判断是不是数组
        if(Array.isArray(cur)){
            return [...pre, ...flat(cur)]
        }
        return [...pre, cur]
    }, [])
}
```



## 62. 有了代理服务器还需要使用cors吗

## 63. ajax、fetch、axios的区别与优缺点

```js
ajax:
	优点：原生自带，没有兼容性问题。
    缺点：代码冗长效率低，容易产生回调地狱。
axios：属于对原生xhr的封装
    axios({
        method:'post',
        url:'/abc/login',
        data:{
            username:'Lan',
            password:'123456'
        }
    }).then(res=>{
        console.log(res);
    }).catch(err=>{
        console.log(err);
    })
fetch：和xhr同级的自带联调api，使用的是promise语法。
	   fetch获取数据分为两步，第一步为确定与服务器端是否连接，在确定连接的情况下，第二步获取数据。
    优点：使用promise不会产生回调地狱，使用关注分离的思想。
    缺点：不具有兼容性
    fetch("url").then(res=>{
        console.log(res)
    })

    fetch("url",{
        method:'post',
        headers:{
            'Content-Type':'application/x-www-form-urlencoded'
        },
        body:new URLSearchParams([["username":"Lan"],["password","123456"]]).toString()
    }).then(res=>{
        console.log(res)
    })
```

## 64. HashRouter和BrowserRouter的区别

```js
HashRouter:
	实际使用的是URL的哈希值。
    path路径里有#
    刷新后state里的值会消失
BrowserRouter：
	实际使用的是H5的history的api
    路径里没有#
    因为使用了history，所以state值还存在
```

## 65. padStart和padEnd

```js
补全位数的语法，padStart是从前面补全，padEnd是从后面补全。接收两个参数，第一个是最终补全的位数，第二个是为其补全的字符串，如果第二个字符串为空，用空格补全。
		let a = 'zz'
        let b = a.padStart(10,'ab')
        console.log(b);//'ababababzz'
复现：
  function padStart(source, num, str=' '){
            let aL = a.length;
            let pad = num - aL;
            let result = '';
            while(result.length < pad){
                result += str;
            }
            result = result.slice(0, pad);
            source = result + source;
            return source
        }
```

## 66. react工作原理

```js
先构建虚拟dom，通过diff算法，与之前的虚拟dom进行比对，形成最终虚拟dom，进而生成真实dom
```

## 67. html 里meta标签

## 68. 网页更好的被SEO，有哪些方法

## 69.构造函数和普通函数的区别

```js
1.构造函数也是普通函数，但是构造函数习惯首字母大写
2.调用方式不同，构造函数用来新建实例对象
3.普通函数返回为undefined，而构造函数返回一个实例对象
```

## 70. 算法题

![算法题](C:\Users\51146\Desktop\微信图片_20220323165851.png)

## 71.函数重载

## 72. 实例对象的delete方法

```js
删除对象的自身属性，不包括原型链上的属性
```

## 73. 

```js
function side(arr) {
    arr[0] = arr[2];
}
function func1(a, b, c = 3) {
    c = 10;
    side(arguments);
    console.log(a + b + c);
}
function func2(a, b, c) {
    c = 10;
    side(arguments);
    console.log(a + b + c);
}
func1(1, 1, 1);
func2(1, 1, 1);
```

## 74. 怎么保护cookie不被泄露

## 75. 详细介绍XSS，CSRF

```js
CSRF原理：
	一般是第三方网站冒充用户访问服务器。利用用户暂存的cookie，然后打开第三方网站，访问服务器。
预防：
	1.同源检测：通过origin Header和Referer Header这两个字段来判断来源的域名，因为CSRF一般是从第三方域名发起的，所以可以有所预防。但是还是不安全
    2.samesite cookie：通过cookie的samesite属性来防止CSRF攻击。有三个值。
    	Strict：完全禁止第三方cookie
        Lax:基本禁止第三方cookie，除了超链接、GET表单、预加载请求
        None：关闭samesite属性，但是必须开启secure属性
    3.token：服务器给用户生成一个token，客户端请求服务器时，会附带上token（不放在cookie中，放在cookie中依然会被窃取），服务器端解密token来判断请求用户的安全性。
    
XSS原理：
	在web页面中插入恶意的js脚本，当用户运行web页面时，就会自动触发js脚本，从而进行攻击。
预防：
	1.httponly：通过设置这个字段，禁止js访问cookie，可以有效防止XSS攻击。
    2.输入检查：不相信任何用户的输入。限制用户非法字符输入，或者出现<,>等这类特殊字符，进行编码获过滤。
	3.输出检查：将输出的内容，进行编码转化。
```



## 76. 设置代理的原理，代理为何能实现跨域

## 77. 箭头函数的this

```
函数被定义的时候的this是谁，以后就算调用call、bind、apply都不会改变它的指向
```

## 78. 快速排序

```js
var sortArray = function (nums) {
    if (nums.length < 2) return nums;
    return quickSort(nums, 0, nums.length - 1)
};

function quickSort(nums, left, right) {
    if (left >= right) return;
    let pivotIndex = sort(nums, left, right);
    quickSort(nums, left, pivotIndex - 1);
    quickSort(nums, pivotIndex + 1, right);
    return nums;
}

function sort(nums, left, right) {
    let pivotIndex = left;
    let pivot = nums[pivotIndex]
    while (left < right) {
        while (left < right && nums[right] >= pivot) {
            right--;
        }
        nums[left] = nums[right];
        while (left < right && nums[left] <= pivot) {
            left++;
        }
        nums[right] = nums[left];
    }
    nums[left] = pivot;
    return left;
}
```

## 79. 简单选择排序

```js
var sortArray = function (nums) {   
    let minIndex = null;
    for (let j = 0;j < nums.length;j++) {
        let min = Infinity;
        for (let i = j;i < nums.length;i++) {
            if (nums[i] < min) {
                min = nums[i];
                minIndex = i
            }
        }
        [nums[j], nums[minIndex]] = [nums[minIndex], nums[j]];
    }
    return nums
};  
```

## 80. cookie详解

```js
cookie的由来：因为http协议是不保存状态的，所以服务器端不知道是不是同一个浏览器在访问它，所以设置了cookie来进行辨认。
客户端自身是没有cookie的，当客户端第一次请求服务器端时，服务器端响应时，顺便通过set-cookie设置cookie放在响应头里发给客户端，之后客户端每次请求时默认携带cookie。
客户端通过使用document.cookie来获取或者设置cookie。

字段：
	name:cookie中name字段在相同域名下是唯一的
    secure：设置了该字段以后，规定cookie只能在https下传输。但是依然可以在客户端上获取修改
    httponly:设置了该字段以后，客户端不允许使用js操作cookie。有效防止了XSS攻击。
    domain：在对应域名下设置cookie，如果没有设置，就会将输入指令的当前页设为domain。只有相同域名才能进行cookie的使用，就算二级域名也不可以。
    path：默认为/，所有的子级路由都可以访问到父级路由的cookie。
	Expires/Max-age：该字段具体内容见上。不设置Expires默认为对话cookie。这里要说的是max-age设置为0，代表删除cookie；设置为负数，代表cookie为临时存储，为会话级别的，关闭浏览器自动删除；设置为正数，规则和上边内容一样

设置cookie：
	 	// 设置cookie
        function setCookie(name, value, time) {
            document.cookie = `${name}=${value}; max-age=${time}`
        }
        // 读取cookie
        function getCookie(name) {
            let arr1 = document.cookie.split(';');
            for (let i in arr1) {
                let arr2 = arr1[i].split('=');
                if (arr2[0] === name) {
                    return arr2[1]
                }
            }
            return ''
        }
        // 删除cookie
        function removeCookie(name) {
            setCookie(name, 0, 0);
        }
```

## 81. CSRF原理和预防

```js
CSRF原理：
	一般是第三方网站冒充用户访问服务器。利用用户暂存的cookie，然后打开第三方网站，访问服务器。
预防：
	1.同源检测：通过origin Header和Referer Header这两个字段来判断来源的域名，因为CSRF一般是从第三方域名发起的，所以可以有所预防。但是还是不安全
    2.samesite cookie：通过cookie的samesite属性来防止CSRF攻击。有三个值。
    	Strict：完全禁止第三方cookie
        Lax:基本禁止第三方cookie，除了超链接、GET表单、预加载请求
        None：关闭samesite属性，但是必须开启secure属性
    3.token：服务器给用户生成一个token，客户端请求服务器时，会附带上token（不放在cookie中，放在cookie中依然会被窃取），服务器端解密token来判断请求用户的安全性。
```

## 82. TCP和UDP的区别

```js
1.TCP是面向连接的，UDP是面向非连接的
2.TCP传输的文件很大，UDP传输的文件小
3.TCP是可靠的（按顺序传送，而且接收必须按顺序接收，快重传），UDP是不可靠的（因为不需要知道对方的接收情况）
4.TCP发送速度慢，UDP发送速度快
```

## 83. http请求

```js
http请求方式大体有8种。
1.get：发送一个请求，来请求服务器资源，返回响应头和数据。请求参数放在url
2.head：和get类似，但是返回的数据只有响应头。目的是为了判断资源是否存在
3.put：向服务器发送数据，客户端指定存放位置。
4.post：向服务器发送数据，但是存放位置由服务器端指定，进行资源的更新和修改。
5.delete：向服务器删除资源
6.option：预检指令，判断服务器是否支持该域名，返回相应的响应头和支持的请求方式
7.trace：回显服务器的客户端请求，用于测试或诊断
8.connect：HTTP/1.1协议中，将客户端和服务器端（或代理服务器）改为keep-alive（管道方式），
```

## 84. SVG

## 85. 模块化了解吗？说说[AMD](https://www.nowcoder.com/jump/super-jump/word?word=AMD)、CMD、requireJS都是啥？

## 86. 堆排序

```js
var sortArray = function (nums) {
    // 利用上浮法建大顶堆
    for (let i in nums) {
        swim(nums, i);
    }
    let end = nums.length - 1;
    [nums[0], nums[end]] = [nums[end], nums[0]];

    // 利用下沉法建大顶堆 
    while(end >= 1){
        sink(nums, 0, end);
        [nums[0], nums[end - 1]] = [nums[end - 1], nums[0]];
        end--;
    }
    return nums;
};

function swim(nums, index) {
    let f_index = Math.floor((index - 1) / 2);
    if (f_index >= 0 && nums[index] > nums[f_index]) {
        [nums[index], nums[f_index]] = [nums[f_index], nums[index]]
        swim(nums, f_index)
    } else {
        return;
    }
}

function sink(nums, index, len) {
    let c_index = index * 2 + 1;
    //判断有没有右孩子    
    if ((c_index + 1) < len) {
        if (nums[c_index] < nums[c_index + 1]) {
            c_index++;
        }
    }
    if (c_index < len && nums[index] < nums[c_index]) {
        [nums[index], nums[c_index]] = [nums[c_index], nums[index]];
        sink(nums, c_index, len);
    }
    else {
        return;
    }
}

```

## 87. 冒泡排序

```js
var sortArray = function (nums) {
    for(let i in nums){
        for(let j = nums.length - 1;j > i;j--){
            if(nums[j] < nums[j - 1]){
                [nums[j], nums[j - 1]] = [nums[j - 1], nums[j]];
            }
        }
    }
    return nums;
};
```

## 88. 归并排序

```js
var sortArray = function (nums) {
    if(nums.length < 2) return nums;
    mergeSort(nums, 0, nums.length - 1);
    return nums;
};

function mergeSort(nums, left, right){
    if(left >= right) return;
    let mid = left + Math.floor((right - left) / 2);
    mergeSort(nums, left, mid);
    mergeSort(nums, mid + 1, right);
    merge(nums, left, mid, right);
}

function merge(nums, left, mid, right){
    let tempArr = [];
    let temp1 = left;
    let temp2 = mid + 1;
    while(temp1 <= mid && temp2 <= right){
        nums[temp1] <= nums[temp2] ? tempArr.push(nums[temp1++]) : tempArr.push(nums[temp2++])
    }
    while(temp1 <= mid){
        tempArr.push(nums[temp1++]);
    }
    while(temp2 <= right){
        tempArr.push(nums[temp2++]);
    }
    nums.splice(left,(right - left + 1), ...tempArr)
}
```

## 89.插入排序

```js
var sortArray = function (nums) {
    if(nums.length < 2) return nums;
    for(let i in nums){
        let temp = nums[i];
        let j;
        for(j = i - 1;j >= 0;j--){
            if(temp < nums[j]){
                nums[j + 1] = nums[j];
                continue;
            }
            else break;
        }
        nums[j + 1] = temp;
    }
    return nums
};
```

## 90. promise.all 应用场景

## 91. react 的 Fiber 架构

## 92. 大数相加

## 93. 实现无缝滑屏，你觉得怎么实现

## 94. MVC MVP MVVM 架构了解吗，他们的使用场景

## 95. 圣杯布局、双飞翼布局

## 96. 怎么同时让多个异步请求并行

## 97. JS 垃圾回收

## 98. 希尔排序

```js
var sortArray = function (nums) {
    if (nums.length < 2) return nums;
    let interval = nums.length;
    while(interval > 0){
        interval >>= 1;
        for(let i = 0;i < interval;i++){
            for(let j = i + interval;j < nums.length;j += interval){
                let temp = j;
                while(temp > i && nums[temp] < nums[temp - interval]){
                    [nums[temp],nums[temp - interval]] = [nums[temp - interval], nums[temp]];
                    temp -= interval;
                }
            }
        }
    }
    return nums;
};
```

## 99. 首页白屏进行优化

```html
1.对于文件较小的，可以采用内敛样式。因为受网速等影响，可能导致外部文件下载变慢
2.将外部文件压缩。同样是可能导致下载变慢
3.更改js的位置，或者添加defer或async，让js不影响html的解析。
4.对大css文件采用媒体查询
5.先渲染可视区域，使用懒加载。
```

## 100.作用域、作用域链、执行上下文

```html
作用域:
	使用var的话，分为函数作用域和全局作用域。使用了let和const的话，在{}里的为块级作用域。var定义的变量默认为window的属性。
	函数作用域里的内容会在函数调用结束结束。
作用域链：
	当前作用域没有定义的变量，称为自由变量。自由变量要获得值时，它会在创建时的作用域向父级作用域寻找，直到找到全局作用域，这称为作用域链。
	例子：
        var x = 10
        function fn() {
          console.log(x)
        }
        function show(f) {
          var x = 20
          (function() {
            f() //10，而不是20
          })()
        }
        show(fn)
	输出的x值为10，因为在调用函数时，该函数作用域里没有定义x的值，就会在创建该函数的上级（全局作用域）去寻找，找到为10。
执行上下文：
	执行上下文和作用域不太一样。作用域是静态的，在创建时就已经确定。执行上下文是被执行前确定，一块作用域，当被调用时产生执行上下文。（类似程序和进程）
```

## 101.constructor

```js
构造函数创造出的对象（实例对象、原型对象）的constructor指向它自己，构造函数的constructor指向Function()
```

## 102. this的优先级

```js
箭头函数中绑定的this，定义后就不会被更改
new 绑定的this，可以更改bind等的this指向
bind、call、apply这三个显示绑定的优先级，高于隐式绑定。
最终优先等级：
	箭头函数this->new绑定this->apply、bind、call显示绑定->function函数被调用的隐式绑定
```

## 103. ssr和前后端分离的区别

## 104. 多行或单行省略

## 105. .div 和div > div > div的优先级

## 106. 如何实现在图片被加载之前的占位符一个image，宽高比16:9

## 107. css div 垂直水平居中，并完成 div 高度永远是宽度的一半（宽度可以不指定）

## 108. setState 是否异步，为什么。如果连续 setState 5 次，react 如何处理

## 109. new 一个构造函数，如果构造函数返回 return {}、return null，会出现什么情况

## 110. CDN 原理

## 111. 3D 的立体图如何实现

## 112. padding和margin的百分比

```js
规定基于包含块的宽度的百分比的内边距或外边距。
```

## 113. 为什么cache-control优先级更高

## 114. no-cache,no-store分别代表什么

## 115. html、css、js文件会放在磁盘缓存还是内存缓存

## 116. 箭头函数和普通函数的区别,箭头函数如何表示不定长的参数

## 117. 多路复用怎么实现的

## 118. 

## 119. [keep](https://www.nowcoder.com/jump/super-jump/word?word=keep)-alive,websocket

## 120. 实现eventbus

## 121. 岛屿数量

## 122. JS脚本阻塞DOM构建,js脚本会不会对css om树影响

## 123. 中间人攻击如何实现？怎样防范？

## 124. 第二个子元素的高度是多少

```html
<div class="container">
    <div style="height: 100px"></div>
    <div style="min-height: 10px"></div>
</div>
<style>
    .container{
        display: flex;
    }
    .container > div {
        width: 100px;
    }
</style>
```

## 125. 继承有哪些方法

## 126. React和Vue的区别

## 127. 如何理解面向对象

```js
面向对象是一种思想，就是把需求笼统但要考虑全面的分成每一类。然后根据自己特殊的要求，通过继承、多态再细化。
这样做的好处是可以很宏观、清晰地看问题。因为如果要面向过程的话，在需求繁多的情况下，就会绕晕自己。
面向对象的三大属性：
封装：隐藏对象的属性和方法，对外开放公共的。
继承：继承一些父类的方法、属性，自己再有创新
多态：调用相同的函数产生不同的结果
```

## 128. 静态成员和私有属性的区别

```js
静态成员是在属性或方法前加static，静态成员只可以给构造函数使用。
私有属性是只可以在类里使用，不可以在类外使用。（封装）
```













