# 前端面经

## 1. babel的作用：

```javascript
babel是一个JS编译器，用来转换最新的JS语法，比如把ES6, ES7等语法转化成ES5语法，从而能够在大部分浏览器中运行。像箭头函数，就可以做转换。
```

## 2. webpack的作用：

```javascript
webpack是个打包工具，webpack把所有文件都当成模块(module)
```

## 3.H5新特性有哪些？

## 4.CSS3新特性有哪些？

## 4.如何监控一个对象的变化？列出你所知道的所有方法

## 5.一段字符从后台动态返回，长度不确定，要求显示一行就居中，两行就左对齐，三行就结尾显示'...'

## 6.数据类型？

```javascript
primitive(原始类型)
1.string 字符类型
2.number 数字类型
3.boolen 布尔类型
4.undefined 未定义
5.null 空
-----------------
6.object 对象类型
```

## 7.undefined和null的区别？

```javascript
首先这两个类型==是相等的，但是===是不同的。所以这两个类型不是一回事。
undefined是声明了一个变量但是未赋值
而null代表空值，它种类属于object，是一个空指针
```

## 8.undefined的几种情况？

```javascript
（1）变量被声明了，但没有赋值时，就等于undefined。

（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

（3）对象没有赋值的属性，该属性的值为undefined。

（4）函数没有返回值时，默认返回undefined。
```

## 9.[],{},null,undefined,NaN分别是TRUE还是FALSE？

```javascript
[],{}是true
null,undefined,NaN是false
```

## 10.==，===运算符注意的问题？

```javascript
1.==的问题
如果两边类型相等，==直接变为===
undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。
String == Boolean，需要两个操作数同时转为Number。
String/Boolean == Number，需要String/Boolean转为Number。
Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)

[] == [] 为false，因为两边类型相等，直接变为===
[] == ![] 为true，因为!优先级高，所以![]是布尔型，从true变为false
[] == 0 为true
[] == true 为false
NaN == NaN 为false，两个都不是数所以无非判定是否相等
{}和谁也不等，因为{}指向了内存中的一个地址，只有有一个和它指向一个地址的对象才对
-----------------------
2.===的问题
===为完全相等才为true
[] === [] 为false，因为它两不在一个地址
```

## 11.prototype和\__proto__的关系:

![关系图](C:\Users\51146\Desktop\图片1.png)

## 12. 防抖和节流？

```javascript
防抖:在一定时间内，一个事件会连续触发多次，不仅没用还会占用浏览器性能。防抖就是让多次执行变为最后一次执行，而且不影响结果。
    	// 防抖
        function debounce(fn, delay) {
            let timer;
            return function (e) {
                clearTimeout(timer);
                timer = setTimeout(() => {
                    fn.call(this, e);
                }, delay);
            }
        }
		window.addEventListener('scroll', debounce(haha, 500));
节流：节流是将多次执行变成每隔一段时间执行
  		// 节流
        function throttle(fn, delay) {
            let lastTime = 0;
            return function (e) {
                let nowTime = new Date();
                if (nowTime - lastTime > delay) {
                    fn.call(this, e);
                    lastTime = nowTime;
                }
            }
        }
		window.addEventListener('scroll', throttle(haha, 3000))
```

## 13. display:none和visibility:hidden的区别有哪些？ 

```java
1.同样是隐藏元素，display:none不占位置，visibility:hidden占位置
2.父元素设置display:none，子元素改成display：block也不会显示。父元素设置visibility：hidden，子元素设置visibility：visible可以显示
3.display：none位置会发生变化，发生回流。visibility：hidden位置不变化，发生重绘
```

## 14. 定位的属性

```java
1.相对定位relative：相对于之前自身的位置，没有脱离文档流
2.绝对定位absolute：相对于包含块的位置，脱离了文档流（包含块：离它最近开启定位的祖先元素）
3.固定定位fixed：相对于页面视口（你看到的页面范围，就算页面利用滚动条拖动，它还是在你看到的位置）的位置，脱离了文档流
4.粘滞定位sticky：到了一定位置，不产生移动，脱离了文档流
```

## 15. CSS权重值

```java
1.!important
2.内联样式
3.id选择器
4.class选择器
5.元素选择器
6.通配选择器
7.继承样式
```

## 16. box-sizing的属性值

```html
content-box和border-box。区别为content-box的width对应的是内容区，border-box的width的范围为边框
```

## 17. 有一个标签设置float浮动，标签下的文字会以什么样的形式呈现

```html
文字围绕标签包裹住，浮动标签属于半脱离文本流
```

## 18. em rem的区别

```html
1em是对应元素的字体大小
1rem（rootem）是html元素的字体大小
```

## 19. 原型链？var person = new Person(); 这个new做了几件事情？

```JavaScript
原型链：在JavaScript中是通过prototype对象指向父类对象，比如Person.prototype就是它的父类对象Object，直到指向Object.prototype.__proto__ = null为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。
new:创建一个新对象 -> 让对象.__proto__ === 构造函数.prototype -> 将this指向新对象 -> 返回结果
复现new
function Person(name, age){
    this.name = name;
    this.age = age;
}
function myNew(className, ...args){
    //Object.create()方法创建一个新的对象，让现有的对象给新的对象提供__proto__。
    let obj = Object.create(className.prototype);
    className.apply(obj, args);
    return obj;
}

let newPerson = myNew(Person, 'zs', 12);
```

## 20. 深浅拷贝（RegExp在深拷贝里是干啥）

```JavaScript
值引用：把值传给新的变量
地址引用：把地址传给新的变量
值引用为深拷贝，地址引用为浅拷贝
------------
深拷贝：
	数组的方法：
    	1.arr1 = arr2.slice();
		2.arr1 = arr2.concat();
		3.arr1 = [...arr2]
		缺点：数组中的引用类型还是没有被深拷贝
	对象的方法：
		1.objString = JSON.stringify(obj);obj1 = JSON.parse(objString)
			缺点：不可以拷贝undefined，function，RegExp等
		2.obj1 = Object.assign({}, obj);
			缺点：对象中的引用类型还是没有被深拷贝
        3.obj1 = {...obj2}
	数组和对象递归深拷贝：
 		function deepClone(source) {
            let target;
            // 首先判断是不是对象类型
            if (typeof source === 'object') {
                // 判断是不是数组
                if (Array.isArray(source)) {
                    target = [];
                    for (let i = 0; i < source.length; i++) {
                        target[i] = deepClone(source[i]);
                    }
                }
                // 判断是不是空指针
                else if (source === null) {
                    target = null
                }
                // 判断是不是正则
                else if (source.constructor === RegExp) {
                    target = source
                }
                // 只剩下普通对象类型
                else {
                    target = {};
                    for (let v in source) {
                        target[v] = deepClone(source[v]);
                    }
                }
            }
            else {
                // 普通类型直接引用
                target = source;
            }
            return target;
        }
```

## 21. 标准盒模型和IE盒模型的区别？

```html
标准盒模型：content范围只有content。相当于box-sizing:content-box
IE盒模型：content范围到border。相当于box-sizing:border-box
```

## 22. 闭包？会造成什么问题？如何避免？

```html
闭包：
	函数里嵌套函数，内部函数调用外部函数的变量，构成闭包。
闭包的作用：
	1.延长局部变量的生命周期
	2.访问函数内部参数
闭包的缺点：
	会造成内存泄漏。
如何避免：
	最后释放闭包
	f = null;
```



## 23. HTTP状态码（查一下看看）

```html
301（资源被永久转移到其他url）
302（临时重定向）
304（协商缓存）
307
------
客户端的问题
401（传参有误）
403（拒绝请求）
404（找不到页面）
------
服务器端问题
500（服务器报错）
503（服务禁止访问）
```

## 24. 页面布局有哪几种

```html
固定布局：设置固定宽高，用px
流式布局：宽度用百分比来设定，高度用px来固定
栅格化布局：将宽度人为划分成均等长度
自适应布局：根据不同的分辨率构造不同的静态页面
响应式布局：流式布局和自适应布局的结合
弹性布局：弹性布局跟流式布局很像，网页宽度不固定，使用 em 或 rem 单位进行相对布局
伸缩布局：使用flex属性来进行布局
-------------
自适应布局和响应式布局对比：
	不同点：
　　　　1.自适应需要开发多套界面；响应式只需开发一套界面。
　　　　2.自适应对页面的屏幕适配实在一定的范围，比如：pc 端大于1024px; 平板 768 ~ 1024px; 手机端小于 768px;响应式是一套页面同时兼容在pc端、平板和手机端的各个不同视口，而不是为每个终端做一个特定的版本，所以需要考虑的状态非常多
	相同点：　
　　　　都是通过检测视口分辨率，使页面适应不同分辨率的视口。
```

## 25. DOM的事件类型

```html
事件传播流程：先捕获到事件点再冒泡。捕获是从外向内，冒泡是从内向外
事件捕获
事件冒泡
```

## 26. target和currentTarget的区别

```html
都是点击以后返回相应的元素。但是点击以后，因为有冒泡的存在，可能有多个事件发生。
1.target:
	发生在事件流的目标阶段
	返回真实点击的那个元素
2.currentTarget：
	发生在事件流的捕获、目标及冒泡阶段
	返回事件发生的那个元素
```

## 27. React生命周期

![生命周期](C:\Users\51146\Desktop\图片2.png)

```js
挂载路线：
constructor-->componentWillMount-->render-->componentDidMount-->componentWillUnmount
更新路线分为三类：
	 (1)父节点使用setState函数，触发render,componentWillReceiveProps可以接收props参数
    	componentWillReceiveProps-->shouldComponentUpdate-->componentWillUpdate-->render-->componentDidUpdate-->componentWillUnmount
     (2)使用setState函数时，触发render
        shouldComponentUpdate-->componentWillUpdate-->render-->componentDidUpdate-->componentwillUnmount
     (3)this.forceUpdate强制刷新，所以不需要shouldComponentUpdate进行判断
		componentWillUpdate-->render-->componentDidUpdate-->componentWillUnmount
```



## 28. bind, apply, call区别

```html
三个都可以改变this的指向
apply:第一个参数为this的新指向，第二个参数是数组，数组里是传入的实参。f.apply(obj,[args])
call:第一个参数为this的新指向，后面的参数是传入的实参。f.call(obj, arg1, arg2, arg3)
bind:用法和前两个不一样,第一个是this的新指向返回一个新函数，然后再调用。f.bind(obj)(arg1,arg2)
```

## 29. 前端缓存

```html
前端缓存可分为两大类：
	http缓存：是在http请求传输时用到的缓存，主要在服务器代码上设置
		1.强缓存：
			-Expires：值为服务器返回该请求结果的缓存到期时间。（http/1.0控制网页缓存的字段）
				规则：客户端请求资源的时间和到期时间作比较，如果超了，强制缓存失效
				缺点：如果时区不同，时间出了问题等，强缓存就会失效
			-Cache-control：（http/1.1控制网页缓存的字段优先级大于Expires）
				参数：
                    public：所有内容都将被缓存（客户端和代理服务器都可缓存）

                    private：所有内容只有客户端可以缓存，Cache-Control的默认取值

                    no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定

                    no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存

                    max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效
				规则：不会出现Expires那样的问题，因为通过相对时间来决定强缓存是否失效。客户端请求时间没有超过max-age，就可以使用浏览器缓存

		2.协商缓存：当强缓存失效以后，浏览器携带缓存标识向服务器发起请求，决定是否可以使用浏览器缓存。
			-Last-Modified / If-Modified-Since：Last-Modified为服务器端响应请求时，该资源文件最后被修改的时间。If-Modified-Since：客户端发起请求时携带Last-Modified的值，与服务器端该资源最后一次做修改的时间进行比对，来决定是否允许客户端请求浏览器缓存。
			-Etag / If-None-Match：（优先级大于Last-Modified / If-Modified-Since）Etag为服务器端响应请求时，返回该资源文件的唯一标识。If-None-Match是客户端再次发起请求时，携带Etag的值。服务器端识别到If-None-Match时，将它的值和当前服务器端该资源文件的Etag值做比较。相同的话返回304可以使用强缓存，不可以的话使用新资源返回200，并将新资源存入浏览器缓存中。
-------------------------------------------------
	本地缓存：
		1.本地存储
			小容量：
				cookie：存储用户信息，
				LocalStorage:一直存储在浏览器内，直到用户清除浏览器缓存数据
				SessionStorage:一直存在，直到关闭标签页
			大容量：
				WebSql:关系型数据库
				IndexDB:非关系型数据库
		2.默认存储
			BFCache:是浏览器在前进后退按钮上为了提升历史页面的渲染速度的一种策略。当到下一个页面时，将该页面的状态存入BFCache中。返回时，直接从BFCache中加载。
--------------------------------------
缓存小结
当浏览器要请求资源时

调用 Service Worker 的 fetch 事件响应
查看 memory cache
查看 disk cache。这里又细分：
如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200
如果有强制缓存但已失效，使用对比缓存，比较后确定 304 还是 200


发送网络请求，等待网络响应
把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)
把响应内容 的引用 存入 memory cache (无视 HTTP 头信息的配置)
把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())
```

## 30. 设计模式

```JavaScript
1.单例模式：
	定义：保证一个类只有一个实例对象，并且提供一个访问点
    实现：用一个变量来标识实例是否已经存在，如果存在，则直接返回已经创建好的实例，反之就创建一个对象
    优点：不用重复开启多个实例，节省内存开销
class SingletonApple {
  	constructor(name, creator, products) {
    this.name = name;
    this.creator = creator;
    this.products = products;
  	}
  	//静态方法
  	static getInstance(name, creator, products) {
    	if(!this.instance) {
      		this.instance = new SingletonApple(name, creator, products);
    	}
   		return this.instance;
  	}
}

let appleCompany = SingletonApple.getInstance('苹果公司', '乔布斯', ['iPhone', 'iMac', 'iPad', 'iPod']);
let copyApple = SingletonApple.getInstance('苹果公司', '阿辉', ['iPhone', 'iMac', 'iPad', 'iPod'])

console.log(appleCompany === copyApple); //true
2.观察者模式：
定义：Subject发布信息，所有观察者都收到信息
const subject = (function () {
  const observers = [];

  function subscribe(callback) {
    console.log('New subscription coming!');
    observers.push(callback);
  }

  function notify(params) {
    for (let i = 0; i < observers.length; i++) {
      try {
        observers[i] && observers[i](params);
      } catch (error) {
        console.error(error);
        // 避免影响其他observer
      }
    }
  }

  function fire(params) {
    console.log('Fire!');
    notify(params);
  }

  return {
    subscribe,
    fire,
  }
})();

const observer1 = (args) => {
  console.log('This is Observer1, Let me process the event');
  console.log(JSON.stringify(args, null, 4));
}

const observer2 = (args) => {
  console.log('This is Observer2, Let me process the event');
  console.log(JSON.stringify(args, null, 4));
}

subject.subscribe(observer1)
subject.subscribe(observer2)

subject.fire({message: 'hello world'});
subject.fire({value: 2021});

3.消息订阅模式：
定义：有一个中间件。发布者发信息在中间件中，订阅者从中间件中获取自己
const broker = (function () {
  const topicSubscribers = {};

  function subscribe(topic, callback) {
    console.log(`New subscription for topic [${topic}] coming!`);
    if (topicSubscribers[topic]) {
      topicSubscribers[topic].push(callback);
    } else {
      topicSubscribers[topic] = [callback];
    }
  }

  function notify(topic, params) {
    if (topicSubscribers[topic]) {
      const subscribers = topicSubscribers[topic]

      for (let i = 0; i < subscribers.length; i++) {
        try {
          subscribers[i] && subscribers[i](params);
        } catch (error) {
          console.error(error);
          // 避免影响其他subscriber
        }
      }
    }
  }

  function fire(topic, params) {
    console.log(`Fire for topic [${topic}]!`);
    notify(topic, params);
  }

  return {
    subscribe,
    fire,
  }
})();

const subscriber1 = (args) => {
  console.log('This is Subscriber1, Let me process the event');
  console.log(JSON.stringify(args, null, 4));
}
broker.subscribe('topic1', subscriber1);

const subscriber2 = (args) => {
  console.log('This is Subscriber2, Let me process the event');
  console.log(JSON.stringify(args, null, 4));
}
broker.subscribe('topic2', subscriber2);

const publisher1 = (function () {
  return {
    publishTopic1: function () {
      broker.fire('topic1', {message: 'Hello World'})
    },
    publishTopic2: function () {
      broker.fire('topic2', {value: 2021})
    },
  }
})();

const publisher2 = (function () {
  return {
    publishTopic1: function () {
      broker.fire('topic1', {message: 'Hello FreewheelLee'})
    },
    publishTopic2: function () {
      broker.fire('topic2', {value: 955})
    },
  }
})();

publisher1.publishTopic1();
publisher1.publishTopic2();

publisher2.publishTopic1();
publisher2.publishTopic2();
```

## 31. 继承

```js
1.Es5继承：
	function Person(name, age){
        this.name = name;
        this.age = age;
    }
	Person.prototype.fun = function(){
        console.log(1);
    }
子类：
	function SmartPerson(name, age, gender){
        Person.call(this, name, age);
        this.gender = gender;
    }
	SmartPerson.prototype = new Person();

2.Es6继承：
	class Person{
        constructor(name, age){
            this.name = name;
            this.age = age;
        }
        fun(){
            console.log(1);
        }
    }
子类：
	class SmartPerson extends Person{
        constructor(name, age, gender){
            super(name, age);
            this.gender = gender;
        }
    }
```



## 32. BFC

```html
BFC（块级格式化上下文）:是一个独立的布局环境，其中的元素布局不受外界的影响。解决了内部塌陷问题、父子外边距问题等
开启BFC:
	1.设置float:left(不推荐)
	2.display:inline-box、table-cell、flex、table-caption或者inline-flex(不推荐)
	3.overflow:hidden(除了visible都可以)
	4.position的值不是static或者relative
```

## 33. 为什么const定义的变量不能修改，定义的对象里的内容能修改

```html
因为const指向的地址不可以改变，但是地址里的内容改变，不会改变指针的指向。
为什么必须初始化？（个人理解）
因为基本类型和指针都放在栈内存，而对象类型都放在堆内存。又因为const的指针不可以改变，所以必须开始就申明指针。如果之后再赋值相当于修改指针位置了，不符合const的逻辑
```

## 34. **sessionStorage、localStorage和cookie的区别**

```html
共同点：都是保存在浏览器端、且同源的 
区别： 
1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递,因为cookie的本质是进行身份验证，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 
2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 
3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 
4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 
```

## 35. css模块化的优点

```html
css模块化定义：
	原始的思维：在设计页面时，从页面整体开始到每一个部分，是一个自上而下的过程，所以很容易css结构只能用在这一个页面上，不能进行css代码复用
	css模块化：是自下而上的，设计每一个模块，这些模块可能用在多个页面只有一些细微的差别，任何一个页面也只不过是这些模块的拼凑。
OOCSS规则：
	上下文无关：这个模块该怎么样就怎么样，不会因为其他元素影响到它。
	不用id，用class：如果要用的代码复用，要用class，因为id只能使用单个元素
BEM规则：
	B 是block，简单理解就是BFC
	E 是element，某一个块独用的子元素。比如菜单里的菜单项
	M 是Modifier，只做修饰的作用
	命名规则：
		B--M,B用M来修饰
		B__E,E是B的子元素
SMACSS规则：
	在OOCSS和BEM的基础上添加了新的概念，在BEM的命名前缀上添加类别，不同类别的处理方式也有不同。
	比如：	
		l- 用作布局规则的前缀：l-inline
		m- 用作模块规则的前缀：m-callout
		is- 用作状态规则的前缀：is-collapsed
		不加前缀就是HTML元素的默认样式
css模块化优点：
	是可预测的，可维护的并且是高性能的
```

## 36. 轮播图组件的实现

## 37. 数组去重几种方法

## 38. http1.0与1.1以及2.0的特点，http首部字段报上来，与https的区别

```js
1.http1.0:
	使用的是短连接，每有一次HTTP请求，就会进行一次TCP的连接。如果上一个请求没有响应，之后的请求无法进行，造成阻塞

2.http1.1:
	使用的是长连接，长连接要求客户端和服务器端的头部connection字段设置为keep-alive。当进行HTTP请求后，TCP的连接就不会断开，直到一定时间没有进行HTTP请求才会断开。服务器根据客户端请求的顺序，来进行响应（比如客户端先请求html再请求css。服务器端就算css资源准备好，也得等html资源响应之后再进行响应），所以也会产生阻塞问题。
	http1.1所谓的并行，只不过是可以同时多开几个TCP连接，但是各个浏览器有TCP连接个数的限制，而且每个TCP连接依旧是单线程的。
	在http1.1加入了缓存处理（强缓存和协商缓存），新增了字段如cache-control。（但是expires是在1.0就有。所以强缓存是啥时候出来的？）

3.http2.0：
	不再采用文本形式，而是采用二进制分层帧，解决了很多解析等问题。每个数据流用信息的方式来发送，信息里由一个或多个帧组成不需要按顺序，每个帧的头部都会有流id（stream_id），最后根据流id来进行封装。实现了真正的并行传输，只在一个TCP上进行。
    还进行了头部压缩。在HTTP2.0之前，每次发送http请求都会将头部信息也发送过去，在同一资源数量非常大的情况下很浪费资源。HTTP2.0使用encoder减少了头部的大小，而且在客户端和服务器端各自cache了一份header_file表，避免重复头部信息的发送，只有有头部信息发生改变才会更新发送。
    新增了服务器推送功能，就是响应除了客户端要求的内容，服务器端可以额外发送资源。（比如客户端请求了html，服务器端不光响应了html内容，还响应了css和js内容）
```

## 39. 短轮询和长轮询

```js
以电商库存为例
1.短轮询：客户端进行库存数量的请求，服务器不管库存有没有更新立即响应库存数量。
2.长轮询：客户端进行库存数量的请求，服务器先将该请求挂起，当有库存数量有变化立即响应，如果一定时间库存数量没有变化，再返回结果。

因为客户端请求是根据有没有响应来判断需不需要继续请求。很明显长轮询的请求次数要比短轮询要少的多，但是长轮询的缺点是会导致资源的浪费
```

## 39. 前端模块化

## 40. 跨域 同源策略 cors jsonp原理 缺点 手写jsonp

```js
同源策略：两个页面具有相同的协议、域名、端口号。
跨域：只要违反同源原则就产生了跨域
cors: 
	整个cors通信过程，是浏览器自动完成的，不需要用户参与。当发现跨域请求时，在请求头部自动添加字段。整个cors通信的关键是服务器，只要在服务器端添加cors接口，就可以实现跨域通信。
    cors分类：
    	cors分为简单请求和非简单请求。这样分类的原因只要是和form表单有关。
        简单请求：
        	满足两大条件的请求就是简单请求
            	(1)请求方法：
                	GET,POST,HEAD
				(2)头部字段:
					Accept、Accept-Language、Content-Language、Last-Event-ID、Content-type:只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
		非简单请求：
        	只要不满足上边任意一条就属于非简单请求。
            每次发送前都得发送预检请求，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些http动词和头信息字段，只有得到肯定答复才会正式发出请求，否则就报错。
jsonp原理：利用script可以跨域的原理，进行跨域请求。
缺点：
	1.因为script发起的是get请求，所以jsonp只能进行get请求
    2.只能发起http请求，所以不能进行页面之间的信息传递
    3.jsonp请求失败不会返回各种http状态码
    4.不安全
手写：
	前端：
    	function fun(data){
            console.log(data);
        }
    	let script = document.createElement('script');
		script.src = 'http://127.0.0.1?callback=fun'
		document.body.appendChild(script);
	后端：
    	import express from 'express'
		const app = express();
		app.get("/", (req, res) => {
            let fun = req.query.callback;
            let data = {
                message:'棒',
                age:12
            }
            res.send(`${fun}(${JSON.stringify(data)})`);
        });
			
		app.listen(80, () => {
            console.log('server is running');
        });
```



## 41. post get区别

## 42. 计网传输层看一下

## 43. 回流 重绘

```js
回流（重排）：
	当页面布局发生变化时，会发生回流
重绘：
	当页面颜色等样式发生变化时，会发生重绘
重绘发生在回流之后。所以只要发生回流必然会发生重绘。
浏览器会做优化，当页面变化到一定程度时
当时使用获取元素尺寸的api时，会引起回流，并且会刷新刷新队列。
```

## 44. http输入url后的详细步骤,如何对首页白屏进行优化

## 45. 平时怎么清除本地的缓存

## 46. CSS的水平垂直居中？已知宽高和未知宽高的都说一下？

## 47. flex:auto和flex:1有什么区别

## 48. link引入和@import引入的区别？

```html
@import用法:
	1.@import url(style.css)
	2.@import url("style.css")
	3.@import "style.css"
1.link是html标签，不止限于引入css样式。而@import属于css范畴，只能加载css
2.link是在页面加载时同时加载。而@import是页面加载完才加载
3.link是html标签所以没有兼容性问题，@import是css2.1之后提出的，所以会有兼容性问题
```

## 49. 宏任务和微任务

```js
优先级：主线程上任务 > 微任务队列里的任务 > 宏任务队列里的任务
宏任务：
	分类：setTimeout,setInterval,requestAnimationFrame，DOM事件，AJAX请求
	当主线程上没有任务，且微任务队列中没有任务，将宏任务队列里的第一个任务放入主线程上
微任务：
	分类：Promise().then(回调)，process.nextTick
	当主线程上没有任务，将微任务队列里的任务放入主线程上。
```

## 50. 网页图片的懒加载，并手写

```js
	对页面进行的一种优化。在加载页面时先不加载图片，直到需要显示的时候，再进行加载。
    将img放入div中，img的src设置为空，可以使用div的默认样式等。然后用到getBoundingClientRect()这个api。getBoundingClientRect().top是元素到视口的距离。document.documentElement.clientHeight是视口的高度。当元素距离视口的距离和视口大小一样或者小于时，就要显示图片了。这时把img的src改成图片路径，图片就加载出来了。
	整个过程要用到防抖或节流，因为滚动事件会连续触发事件，影响性能。
    	let dataSrc = './img/u=1580462615,710030920&fm=253&fmt=auto&app=138&f=JPEG.webp';
        let box = document.getElementById('box');
        let img = document.getElementsByTagName('img')[0];
        let lazyLoad = function (e) {
            if(box.getBoundingClientRect().top <= document.documentElement.clientHeight){
                console.log('成了');
                img.src = dataSrc;
            }
        }
         // 防抖
        function debounce(fn, delay) {
            let timer;
            return function (e) {
                clearTimeout(timer);
                timer = setTimeout(() => {
                    fn.call(this, e);
                }, delay);
            }
        }
  		window.addEventListener('scroll', debounce(lazyLoad, 500));
```

## 51. http和https的区别

```js
http是明文传输协议，所以信息被截取以后，安全隐患很大。https要比http安全，因为在https下多加了一SSL/TSL层。
```

## 52. 对称加密和非对称加密

```js
对称加密：
	对话双方用的同一个密钥。A方用密钥将明文加密以后，传给B方，B方通过这个密钥将密文解成明文。
非对称加密：
	对话双方各自用自己的一对密钥。当A方想给B方发文件，这时就让B方把他的公钥发给A，A将自己的明文通过B给的公钥加密，发给B，B用自己的密钥对该密文进行解密。
对称加密优缺点：
	优点：加密解密速度快。
    缺点：密钥的传递会有安全问题。
非对称加密优缺点：
	优点：公钥传递不用考虑安全性。
    缺点：加密解密速度慢
```

## 53. https的加密原理

```js
	https用到了对称加密和非对称加密。
	考虑到加密解密的效率所以要用对称加密，但是对称加密的传输有了安全问题。利用非对称加密的安全传输性，通过非对称加密将对称加密的密钥传输给浏览器和服务器双方。
	但是使用非对称加密也会有隐患。服务器端将公钥A传给浏览器，中间人进行劫持，留下公钥A，将自己的公钥B传给浏览器，浏览器将自己的对称密钥x通过公钥B传给中间人，中间人利用自己的密钥B解密，得到密钥x，然后将密钥x通过公钥A传给服务器。整个过程服务器和浏览器不知道，但是中间人已经拿到了密钥x。
	所以为了解决这个问题，引入了权威机构CA发布的数字证书，浏览器就知道自己接收到的公钥是不是来自服务器。首先每个电脑都有CA机构的公钥。CA发送证书时，会将一串明文进行hash，然后CA利用私钥将该数据加密生成数字签名，将明文和数字签名发给浏览器。浏览器将数字签名用CA的公钥解开为S’，然后将明文进行hash形成T’。将S’和T’进行比较，如果相同说明没有问题。
	进行一次hash的原因是非对称加密，有长度的限制，而且长度固定以后，会加快非对称加密和解密的速度。
    每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？显然不会，太耗时。服务器端会根据sessionID存储密钥，浏览器端会每次传送时将sessionID也一并传送过去。服务器端根据sessionID来寻找密钥。
```

## 54. https通信流程

```js
1.客户端向服务器端请求CA证书
2.客户端验证证书
3.验证通过
4.通过服务器公钥加密随机生成的对称密钥x
5.服务器通过密钥解密获得对称密钥x
6.双方进行通信
```

## 55. element.style和getComputedStyle()的区别

```html
element.style可以修改element样式是可读写，但是只能涉及到元素的内联样式
getComputedStyle()是只读属性，可以读到元素的最终属性（包括内敛、外部样式等）。
getComputedStyle(元素，伪元素字符串)
<style>
    h3::after {
        content: "rocks!";
    }
</style>

<h3>generated content</h3>

<script>
    let h3 = document.querySelector('h3'),
    result = getComputedStyle(h3, '::after').content;
    alert(`the generated content is: ${result}`);
    console.log(`the generated content is: ${result}`);
    // the generated content is: "rocks!"
</script>
```

## 56. offsetHeight、clientHeight、scrollHeight的区别

```js
offsetHeight是加边框的大小
clientHeight是加padding的大小
scrollHeight是整个内容区的文本大小
```

## 57. offsetTop、clientTop、scrollTop的区别

```js
offsetTop是顶部距离包含块的距离
clientTop是上边框的宽度
scrollTop是滚动的距离
```

## 58. 手撕Promise

```js
function Promise(executor) {
    // 设定初始状态
    this.PromiseState = 'pending';
    // 设定promise的值
    this.PromiseResult = null;
    // 设定发生异步时，存入的then里的函数
    this.callback = [];
    // 调用resolve，改变Promise状态为fulfilled
    let resolve = (data) => {
        this.PromiseState = 'fulfilled';
        this.PromiseResult = data;
        // 等异步结束，响应对应的多个then函数
        for (let i in this.callback) {
            this.callback[i].onResolve(data)
        }
    }
    // 调用reject，改变Promise状态为reject
    let reject = (data) => {
        this.PromiseState = 'reject';
        this.PromiseResult = data;
        // 等异步结束，响应对应的多个then函数
        for (let i in this.callback) {
            this.callback[i].onReject(data);
        }
    }
    // 捕获报错，报错Promise从pending状态变为reject状态
    try {
        // 同步执行promise执行器里的函数  
        executor(resolve, reject);
    } catch (error) {
        reject(error)
    }

};
Promise.prototype.then = function (onResolve, onReject) {
    return new Promise((resolve, reject) => {
        // 当状态为fulfilled时，执行第一个形参里的函数
        if (this.PromiseState === 'fulfilled') {
            let result = onResolve(this.PromiseResult)
            // 判断返回是不是Promise对象
            if (result instanceof Promise) {
                // 当第一个函数返回结果为Promise的fulfilled时，then返回promise的fulfilled状态
                if (result.PromiseState === 'fulfilled') {
                    resolve(result);
                }
                // 否则，返回Promise的reject
                if (result.PromiseState === 'reject') {
                    reject(result);
                }
            }
            else {
                resolve(result);
            }
        }
        // 当状态为reject时，执行第二个形参里的函数
        if (this.PromiseState === 'reject') {
            let result = onReject(this.PromiseResult)
            if (result instanceof Promise) {
                // 当第一个函数返回结果为Promise的fulfilled时，then返回promise的fulfilled状态
                if (result.PromiseState === 'fulfilled') {
                    resolve(result);
                }
                // 否则，返回Promise的reject
                if (result.PromiseState === 'reject') {
                    reject(result);
                }
            }
            else {
                resolve(result);
            }
        }
        // 当状态为pending时，将函数存入callback数组中，等状态变化后执行
        if (this.PromiseState === 'pending') {
            this.callback.push({
                onResolve: () => {
                    try {
                        let result = onResolve(this.PromiseResult)
                        // 判断返回是不是Promise对象
                        if (result instanceof Promise) {
                            result.then(v => {
                                resolve(v)
                            }, r => {
                                reject(r)
                            })
                        }
                        else {
                            resolve(result);
                        }
                    } catch (error) {
                        reject(error)
                    }

                },
                onReject: () => {
                    try {
                        let result = onReject(this.PromiseResult)

                        if (result instanceof Promise) {
                            // 当第一个函数返回结果为Promise的fulfilled时，then返回promise的fulfilled状态
                            if (result.PromiseState === 'fulfilled') {
                                resolve(result);
                            }
                            // 否则，返回Promise的reject
                            if (result.PromiseState === 'reject') {
                                reject(result);
                            }
                        }
                        else {
                            resolve(result);
                        }
                    } catch (error) {
                        reject(error)
                    }

                }
            })
        }
    })

}
```

## 59. 受控组件和非受控组件

```js
受控组件：
	有多个输入框时，把输入的内容存在state里，保存下来的组件叫受控组件
非受控组件：
	即存即用的组件，一般存在ref中
一般最好使用受控组件，因为react官方建议少用ref
```

## 60.函数柯里化和闭包

```js
函数柯里化：是特殊的闭包，将多层函数里的参数，一起使用最后返回。
闭包：使用函数内部参数
```

## 61. 











